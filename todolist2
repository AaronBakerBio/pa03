#! /opt/miniconda3/bin/python3
'''
todo2 is an app that maintains a todo list
just as with the todo code in this folder.

but it also uses an Object Relational Mapping (ORM)
to abstract out the database operations from the
UI/UX code.

The ORM, TodoList, will map SQL rows with the schema
    (rowid,title,desc,completed)
to Python Dictionaries as follows:

(5,'commute','drive to work',false) <-->

{rowid:5,
 title:'commute',
 desc:'drive to work',
 completed:false)
 }

In place of SQL queries, we will have method calls.

This app will store the data in a SQLite database ~/todo.db

Recall that sys.argv is a list of strings capturing the
command line invocation of this program
sys.argv[0] is the name of the script invoked from the shell
sys.argv[1:] is the rest of the arguments (after arg expansion!)

Note the actual implementation of the ORM is hidden and so it 
could be replaced with PostgreSQL or Pandas or straight python lists

'''

from todolist import TodoList
import sys


# here are some helper functions ...
p_states = ["quit", "show categories", "add category", "modify category", "show transactions", "add transaction", "delete transaction", "summarize transactions by date", "summarize transactions by month", "summarize transactions by year", "summarize transactions by category", "print this menu"]

def print_usage():
    ''' print an explanation of how to use this command '''
    count  = 0
    for x in p_states:
        print(str(count) + ". "+ x)
        count += 1
        
def print_todos(todos):
    ''' print the todo items '''
    if len(todos)==0:
        print('no tasks to print')
        return
    print('\n')
    print("%-10s %-10s %-30s %-10s"%('item #','title','desc','completed'))
    print('-'*40)
    for item in todos:
        values = tuple(item.values()) #(rowid,title,desc,completed)
        print("%-10s %-10s %-30s %2d"%values)

def print_categories(categories):
    if len(categories) == 0:
        print("No categories entered")
    else:
        print("Categories")
        print('-' * 10)
        category = set(*categories)
        for x in category:
            print(x)


def process_args(arglist):
    ''' examine args and make appropriate calls to TodoList'''
    todolist = TodoList()
    arg = arglist
    if arglist == None:
        print_usage()

    elif arg == p_states[0]:
        print("goodbye")

    elif arg == p_states[1]:
        #vanilla 
        print_categories(todolist.selectCategories())
    elif arg == p_states[2]:
        category = input("Please enter a category")
        catbool = todolist.add_category(category)
        if catbool is True:
            print("This category already exists")
        else:
            print("Category added")
    elif arg == p_states[5]:
        #add transaction
        arg = arg.removeprefix(p_states[2] + " ")
        arg = arg.split()
        task = {}
        task['item #'] = input("Please enter an item number")
        task['amount'] = input("Please enter the amount")
        task['category'] = input("Please enter a category")
        task['date'] = int(input("Please enter the date"))
        task['description'] = input("Please enter a description")
        todolist.add(task)
        
    elif arg == p_states[4]:
        if len(arglist)!= 2:
            print_usage()
        else:
            todolist.setComplete(arglist[1])
    #deletion
    elif arg == p_states[6]:
        if len(arglist)!= 2:
            print_usage()
        else:
            todolist.delete(arglist[1])
    
    else:
        print_usage()   


    
def main():
    if len(sys.argv) == 1:
        print_usage()
        args = ""
        while args != 'quit':
            args = input("Enter a choice")
            process_args(args)
            print('-'*40+'\n'*3)
    else:
        # read the args and process them
        args = sys.argv[1:]
        process_args(args)
        print('-'*40+'\n'*3)

if __name__ == "__main__":
    main()

